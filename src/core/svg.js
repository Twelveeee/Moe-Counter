const dataUriCache = new Map();

export async function renderCountSvg({
  assets,
  manifest,
  count,
  theme = "moebooru",
  padding = 7,
  prefix = -1,
  offset = 0,
  align = "top",
  scale = 1,
  pixelated = "1",
  darkmode = "auto",
}) {
  const themes = manifest.themes || {};

  if (!(theme in themes)) {
    theme = "moebooru";
  }

  const themeData = themes[theme];
  if (!themeData) {
    throw new Error(`Theme not found: ${theme}`);
  }

  const countArray = String(count).padStart(padding, "0").split("");

  if (prefix >= 0) {
    countArray.unshift(...String(prefix).split(""));
  }

  if (themeData._start) {
    countArray.unshift("_start");
  }

  if (themeData._end) {
    countArray.push("_end");
  }

  const uniqueChars = [...new Set(countArray)];
  const charMap = new Map();

  await Promise.all(
    uniqueChars.map(async (char) => {
      const image = themeData[char];

      if (!image) {
        throw new Error(`Theme image not found: ${theme}/${char}`);
      }

      const data = await getDataUri(assets, image.path, image.mime);
      charMap.set(char, {
        width: image.width * scale,
        height: image.height * scale,
        data,
      });
    })
  );

  let x = 0;
  let maxHeight = 0;

  const defs = uniqueChars.reduce((ret, char) => {
    const image = charMap.get(char);
    maxHeight = Math.max(maxHeight, image.height);

    return `${ret}\n    <image id="${char}" width="${toFixed(image.width, 5)}" height="${toFixed(image.height, 5)}" xlink:href="${image.data}" />`;
  }, "");

  const parts = countArray.reduce((ret, char) => {
    const image = charMap.get(char);

    let yOffset = 0;
    if (align === "center") {
      yOffset = (maxHeight - image.height) / 2;
    } else if (align === "bottom") {
      yOffset = maxHeight - image.height;
    }

    const useTag = `${ret}\n    <use x="${toFixed(x, 5)}"${yOffset ? ` y="${toFixed(yOffset, 5)}"` : ""} xlink:href="#${char}" />`;

    x += image.width + offset;
    return useTag;
  }, "");

  x -= offset;

  const style = `
  svg {
    ${pixelated === "1" ? "image-rendering: pixelated;" : ""}
    ${darkmode === "1" ? "filter: brightness(.6);" : ""}
  }
  ${darkmode === "auto" ? "@media (prefers-color-scheme: dark) { svg { filter: brightness(.6); } }" : ""}
  `;

  return `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by https://github.com/Twelveeee/Moe-Counter-Cloudflare -->
<svg viewBox="0 0 ${toFixed(x, 5)} ${toFixed(maxHeight, 5)}" width="${toFixed(x, 5)}" height="${toFixed(maxHeight, 5)}" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Moe Counter!</title>
  <style>${style}</style>
  <defs>${defs}
  </defs>
  <g>${parts}
  </g>
</svg>
`;
}

async function getDataUri(assets, relativePath, mime) {
  const key = `${relativePath}:${mime}`;

  if (dataUriCache.has(key)) {
    return dataUriCache.get(key);
  }

  const bytes = await assets.readBinary(relativePath);
  const dataUri = `data:${mime};base64,${bytesToBase64(bytes)}`;

  dataUriCache.set(key, dataUri);
  return dataUri;
}

function bytesToBase64(bytes) {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(bytes).toString("base64");
  }

  let binary = "";
  const chunkSize = 0x8000;

  for (let i = 0; i < bytes.length; i += chunkSize) {
    binary += String.fromCharCode(...bytes.subarray(i, i + chunkSize));
  }

  return btoa(binary);
}

function toFixed(num, digits = 2) {
  return Number(num)
    .toFixed(digits)
    .replace(/\.0+$/, "")
    .replace(/(\.\d*?)0+$/, "$1");
}
